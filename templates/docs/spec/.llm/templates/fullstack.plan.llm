# Plan: Full-Stack Feature — {Feature Name}

> Use this template for features that span database, backend API, and frontend UI.
> For backend-only features, use `feature.plan.llm` instead.

## Metadata

| Field | Value |
|-------|-------|
| **Created** | {timestamp} |
| **Agent ID** | {agent-id} |
| **Status** | planning |
| **Priority** | {P0 / P1 / P2} |
| **Depends On** | {none or list of plan files} |
| **Branch** | feature/{feature-name} |

---

## Objective

{One sentence describing the full-stack feature to be implemented}

---

## User Approval Gate

> **IMPORTANT**: Present this plan to the user before starting implementation.

- [ ] Plan reviewed by user
- [ ] User approved approach
- [ ] Feedback incorporated

---

## Business Context

- **Business Spec**: `biz/{feature-name}.md`
- **User Stories**: {key stories}
- **Acceptance Criteria**: {from business spec}

---

## Prerequisites

### Specs to Read

Read only specs that exist — skip any not yet created:

- [ ] `framework/go-generation-guide.md` (if Go backend)
- [ ] `framework/typescript-ui-guide.md` (frontend patterns)
- [ ] `framework/performance-guide.md` (performance budgets)
- [ ] Other available framework specs
- [ ] {Project-specific specs}

---

## Parallel Execution Strategy

This plan supports concurrent work by multiple agents or subagents:

```
Agent/Subagent A: Phase 1 (DB) → Phase 2 (Service) → Phase 3 (API)
Agent/Subagent B: Phase 4 (Frontend) — starts after API contract is defined (Step 3.3)
Agent/Subagent C: Phase 5 (E2E Tests) — starts after Phase 3 + 4 complete
```

### Synchronization Points

| After Phase | What's Available | Unblocks |
|-------------|-----------------|----------|
| Phase 1 | DB schema + queries | Phase 2 |
| Phase 2 | Service interfaces | Phase 3 |
| Step 3.3 (API types) | Request/response contracts | Phase 4 (frontend can start) |
| Phase 3 + 4 | Full stack running | Phase 5 (E2E) |

---

## Implementation Steps

### Phase 1: Database Layer

- [ ] **1.1**: Design schema for {entity}
- [ ] **1.2**: Create migration files
- [ ] **1.3**: Write database queries
- [ ] **1.4**: Generate typed database code
- [ ] **Quality gate**: `go build ./...` passes

### Phase 2: Service Layer

- [ ] **2.1**: Define service interface
- [ ] **2.2**: Implement business logic
- [ ] **2.3**: Add unit tests
- [ ] **Quality gate**: `go test -race ./internal/service/...`

### Phase 3: API Layer

- [ ] **3.1**: Create request/response types (share with frontend)
- [ ] **3.2**: Implement handlers
- [ ] **3.3**: Register routes and middleware
- [ ] **3.4**: Add API tests
- [ ] **Quality gate**: `go test -race ./...`

### Phase 4: Frontend

- [ ] **4.1**: Create API client/hooks based on types from Step 3.1
- [ ] **4.2**: Build page layout and routing
- [ ] **4.3**: Implement components (forms, lists, detail views)
- [ ] **4.4**: Add loading states, error handling, empty states
- [ ] **4.5**: Ensure accessibility (keyboard nav, ARIA, contrast)
- [ ] **4.6**: Add component tests
- [ ] **Quality gate**: `npm run build && npm run test && npm run lint`

### Phase 5: End-to-End

- [ ] **5.1**: Write E2E tests covering the happy path
- [ ] **5.2**: Write E2E tests for error cases
- [ ] **5.3**: Verify responsive design
- [ ] **Quality gate**: All E2E tests pass

### Phase 6: Polish & Documentation

- [ ] **6.1**: Performance check against budgets
- [ ] **6.2**: Update API documentation
- [ ] **6.3**: Update PROGRESS.md with learnings
- [ ] **6.4**: User review of completed feature

---

## API Contract

### Endpoints

| Method | Path | Description | Request | Response |
|--------|------|-------------|---------|----------|
| POST | `/api/v1/{entities}` | Create | `Create{Entity}Request` | `{Entity}Response` |
| GET | `/api/v1/{entities}` | List | Query params | `List{Entity}Response` |
| GET | `/api/v1/{entities}/:id` | Get | — | `{Entity}Response` |
| PATCH | `/api/v1/{entities}/:id` | Update | `Update{Entity}Request` | `{Entity}Response` |
| DELETE | `/api/v1/{entities}/:id` | Delete | — | 204 |

### Shared Types

```typescript
// Define types here that both backend and frontend will use
interface {Entity}Response {
  id: string;
  // ...
}
```

---

## Files

### Files to Modify

| File | Change Type | Claimed By |
|------|-------------|------------|
| Routes file | Add routes | {agent-id} |

### Files to Create

| File | Purpose | Phase |
|------|---------|-------|
| Migration file | DB schema | 1 |
| Service file | Business logic | 2 |
| Handler file | API endpoints | 3 |
| Frontend page | UI | 4 |
| E2E test file | Integration tests | 5 |

---

## Decisions

### Decision 1: {Topic}

- **Choice**: {decision}
- **Alternatives**: {considered}
- **Rationale**: {why}

---

## Progress Log

### {timestamp}
- Started: Planning
- Next: User approval, then Phase 1

---

## Verification

- [ ] All phases complete
- [ ] All quality gates pass
- [ ] E2E tests pass
- [ ] Accessibility audit passes
- [ ] Performance within budgets
- [ ] PROGRESS.md updated
- [ ] User reviewed feature
